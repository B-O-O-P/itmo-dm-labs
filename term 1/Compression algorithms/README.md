
# Лабораторная работа по алгоритмам сжатия информации

## Задача A. Код Хаффмана

Имя входного файла: huffman.in

Имя выходного файла: huffman.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Заданы числа p_1,p_2,...,p_n.
Предположив, что имеется текст, содержащий p_1 символов c_1, p_2 символов c_2 и т. д., постройте код Хаффмана и найдите суммарное число битов, необходимое для кодирования такого текста.

###  Формат входных данных

Первая строка воходного файла содержит число _n_ (2 ≤ _n_ ≤ 1000). Вторая строка содержит _n_ целых чисел p_1, p_2,..., p_n (1 ≤ p_i ≤ 10^9).

### Формат выходных данных

Выведите одно число - число битов, необходимое для кодирования текста с заданным во входном файле количеством вхождений каждого символа.

### Примеры

**huffman.in**
```
10
1 2 3 4 5 6 7 8 9 10
```

**huffman.out**
```
173
```

### [Решение](A.java)

## Задача B. Преобразование Барроуза-Уиллера

Имя входного файла: bwt.in

Имя выходного файла: bwt.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Реализуйте преобразование Бароуза-Уиллера.

Рассмотрим строку _s_, состоящую из строчных латинских букв.

Отсортируем в лексиграфическом порядке все ее циклические сдвиги. Выпишем последние буквы получившихся строк в порядке сортировки.

### Формат входных данных

Входной файл содержит строку, содержащую не более 1000 строчных букв латинского алфавита.

### Формат выходных данных

Выведите результат преобразования Барроуза-Уиллера.

### Примеры

**bwt.in**
```
abacaba
```

**bwt.out**
```
bcabaaa
```

### [Решение](B.java)


## Задача C. Move To Front

Имя входного файла: mtf.in

Имя выходного файла: mtf.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Реализуйте преобразование MTF.

Рассмотрим строку из строчных латинских букв.

Исходно бувы от 'a' до 'z' организованы в список в алфавитном порядке. По очереди рассматриваются слова из латинских букв. Для каждой буквы кодируемой строки выполняется следующее:

* Выводится ее номер в списке (нумерация с 1)

* Она перемещается на первую позицию в списке.

### Формат входных данных

Входной файл содержит строку, содержащую не более 1000 строчных букв латинского алфавита.

### Формат выходных данных

Пусть длина строки во входном файле равна _n_. Выведите _n_ чисел от 1 до 26, которые будет выведены при преобразовании Move To Front.

### Примеры

**mtf.in**
```
abacaba
```

**mtf.out**
```
1 2 2 3 2 3 2
```

### [Решение](C.java)


## Задача D. Алгоритм LZW

Имя входного файла: lzw.in

Имя выходного файла: lzw.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Реализуйте кодирование в алгоритме LZW.

Рассмотрим строку _s_, состоящую из строчных латинских букв. 

Исходном имеется словарь, содержазщий символы от 'a' до 'z' с кодами от 0 до 25, соответственно. Алгоритм поддерживает текущий буфер _t_, исходно инициализированный пустой строкой. 
Последовательно рассматриваются символы строки _s_. Пусть очередной символ строки равен _c_.

Если строка _t_ есть в словаре, то _t_ присваивается _tc_ и обработка символа завершается. 

Иначе выводится код _t_ и строка _tc_ помещается в словарь с минимальным свободным кодом.
После этого _t_ присваивается значение _c_ и обработка символа завершается.

После этого просмотра всех символов код оставшегося _t_ выводится.

### Формат входных данных

Входной файл содержит строку, содержащую не более 1000 строчных букв латинского алфавита.

### Формат выходных данных

Выведите коды, которые выводятся по мере выполнения алгоритма.

### Примеры

**lzw.in**
```
abacaba
```
**lzw.out**
```
0 1 0 2 26 0
```

### [Решение](D.java)
