# Лабораторная работа по комбинаторике

## Задача 1. Двоичные коды

Имя входного файла: allvectors.in

Имя выходного файла: allvectors.out

Во входном файле задано число _n_. Выведите в выходной файл в лексикографическом порядке

все двоичные вектора длины _n_. 1 ≤ _n_ ≤ 16.

### Пример

**allvectors.in**
```
3
```

**allvectors.out**
```
000
001
010
011
100
101
110
111
```

### [Решение](Combinatorics1.java)

## Задача 2. Коды Грея для двоичных векторов

Имя входного файла: gray.in

Имя выходного файла: gray.out

Во входном файле задано число _n_. Выведите в выходной файл в порядке произвольного кода
Грея все двоичные вектора длины _n_. 1 ≤ _n_ ≤ 16.

### Пример

**gray.in**
```
3 
```

**gray.out**
```
000
001
011
010
110
111
101
100
```

### [Решение](Combinatorics2.java)

## Задача 3. Коды Антигрея

Имя входного файла: antigray.in

Имя выходного файла: antigray.out

Во входном файле задано число _n_. Выведите в выходной файл все троичные вектора длины _n_,
так чтобы в соседних отличались значения на всех _n_ позициях. 1 ≤ _n_ ≤ 10.

### Пример

**antigray.in**
```
2 
```

**antigray.out*
```
11
22
00
12
20
01
10
21
02
```

### [Решение](Combinatorics3.java)

## Задача 4. Цепной код

Имя входного файла: chaincode.in
Имя выходного файла: chaincode.out
Во входном файле задано числоn. Выведите в выходной файл все двоичные вектора длиныn,
в порядке какого-нибудь цепного кода. 1 ≤n≤ 15.

## Пример

```
chaincode.in chaincode.out
3 000
001
010
101
011
111
110
100
```

### [Решение](Combinatorics4.java)

## Задача 5. Телеметрия

Имя входного файла: telemetry.in

Имя выходного файла: telemetry.out

Во входном файле заданы числа _n_ и _k_. Выведите в выходной файл все _k_-ичные вектора длины
_n_, так чтобы у двух подряд идущих векторов, значения на всех кроме одной позиции совпадали, а
значения на оставшейся позиции отличались ровно на 1 (_n_ ≥ 2 , 2 ≤ _k_ ≤ 9 , 1 ≤ _kn_ ≤ 100000 ).

### Пример

**telemetry.in**
```
3 3
```

**telemetry.out** 
```
000
100
200
210
110
010
020
120
220
221
121
021
011
111
211
201
101
001
002
102
202
212
112
012
022
122
222
```

### [Решение](Combinatorics5.java)

## Задача 6. Двоичные вектора

Имя входного файла: vectors.in

Имя выходного файла: vectors.out

Во входном файле задано число _n_ ( 1 ≤ _n_ ≤ 16 ). В первой строке выходного файла выведите
количество двоичных векторов длины _n_ в которых нет двух единиц подряд. В следующих строках
выведите сами эти вектора в лексикографическом порядке по одному в строке.

### Пример

**vectors.in**
```
3 5
```

**vectors.out**
```
000
001
010
100
101
```

### [Решение](Combinatorics6.java)

## Задача 7. Перестановки

Имя входного файла: permutations.in

Имя выходного файла: permutations.out

Во входном файле задано число _n_ ( 1 ≤ _n_ ≤ 8 ). Выведите в выходной файл в лексикографическом
порядке все перестановки чисел от 1 до _n_.

### Пример

**permutations.in**
```
3
```

**permutations.out**
``` 
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

### [Решение](Combinatorics7.java)

## Задача 8. Сочетания

Имя входного файла: choose.in

Имя выходного файла: choose.out

Во входном файле заданы числа _n_ и _k_. Выведите в выходной файл все сочетания по _k_ из чисел
от 1 до _n_ в лексикографическом порядке. 1 ≤ _k_ ≤ _n_ ≤ 16.

### Пример

**choose.in**
```
4 2
```

**choose.out**
```1 2
1 3
1 4
2 3
2 4
3 4
```

### [Решение](Combinatorics8.java)

## Задача 9. Правильные скобочные последовательности

Имя входного файла: brackets.in

Имя выходного файла: brackets.out

Во входном файле задано число _n_. Выведите в выходной файл все правильные скобочные после
довательности с _n_ открывающимися скобками в лексикографическом порядке, "(" < ")". 1 ≤ _n_ ≤ 10.

### Пример

**brackets.in**
```
4 
```

**brackets.out**
```
(((())))
((()()))
((())())
((()))()
(()(()))
(()()())
(()())()
(())(())
(())()()
()((()))
()(()())
()(())()
()()(())
()()()()
```

### [Решение](Combinatorics9.java)

## Задача 10. Разбиения на слагаемые

Имя входного файла: partition.in

Имя выходного файла: partition.out

Во входном файле задано число _n_ ( 2 ≤ _n_ ≤ 40 ). Выведите в выходной файл все разбиения
числа _n_ на слагаемые по одному в строке. Слагаемые следует выводить в возрастающем порядке.
Разбиения отличающиеся только порядком слагаемых считаются одинаковыми.

### Пример

**partition.in**
```
4
```

**partition.out**
```
1+1+1+1
1+1+2
1+3
2+2
4
```

### [Решение](Combinatorics10.java)

## Задача 11. Подмножества

Имя входного файла: subsets.in

Имя выходного файла: subsets.out

Во входном файле задано число _n_. Выведите в выходной файл все подмножества множества
{ 1 , 2 ,... , _n_} в лексикографическом порядке. 1 ≤ _n_ ≤ 10.

### Пример

**subsets.in**
```
3
```

**subsets.out**
```
1
1 2
1 2 3
1 3
2
2 3
3
```

### [Решение](Combinatorics11.java)

## Задача 12. Разбиения на множества

Имя входного файла: part2sets.in

Имя выходного файла: part2sets.out

Во входном файле заданы числа _n_ и _k_. Выведите в выходной файл все разбиения _n_-элементного
множества на _k_ неупорядоченных множеств. Разбиения можно выводить в любом порядке. Внутри
разбиения множества можно выводить в любом порядке. Внутри множества числа надо выводить в
возрастающем порядке. Следуйте формату из примера. 1 ≤ _k_ ≤ _n_ ≤ 10.

### Пример

**part2sets.in**
```
4 2
```

**part2sets.out**
```
1
2 3 4

2
1 3 4

3
1 2 4

4
1 2 3

1 2
3 4

1 3
2 4

2 3
1 4
```

## Задача 13. Перестановка по номеру

Имя входного файла: num2perm.in

Имя выходного файла: num2perm.out

Во входном файле задано числа _n_ и _k_. Выведите в выходной файл _k_-ю в лексикографическом
порядке перестановку чисел от 1 до _n_. Перестановки занумерованы от 0 до _n_!− 1. 1 ≤ _n_ ≤ 18 ,
0 ≤ _k_ ≤ _n_!− 1.

### Пример

**num2perm.in**
```
3 4
```

**num2perm.out**
``` 
3 1 2
```

### [Решение](Combinatorics13.java)

## Задача 14. Номер по перестановке

Имя входного файла: perm2num.in

Имя выходного файла: perm2num.out

Во входном файле задано число _n_ и затем перестановка чисел от 1 до _n_. Выведите в выходной
файл номер заданной перестановки в лексикографическом порядке всех перестановок чисел от 1 до
_n_. Перестановки занумерованы, начиная с 0. 1 ≤ _n_ ≤ 18.

### Пример

**perm2num.in**
```
3
1 3 2
```

**perm2num.out**
```
1
```

### [Решение](Combinatorics14.java)

## Задача 15. Сочетание по номеру

Имя входного файла: num2choose.in

Имя выходного файла: num2choose.out

Во входном файле заданы числа _n_, _k_ и _m_. Выведите в выходной файл _m_-е в лексикографическом
порядке сочетание по _k_ из чисел от 1 до _n_. Сочетания занумерованы, начиная с 0. 1 ≤ _k_ ≤ _n_ ≤ 30 ,
0 ≤ _m_ ≤ ( n k ) - 1

### Пример

**num2choose.in**
```
4 2 3
```

**num2choose.out**
```
2 3
```

### [Решение](Combinatorics15.java)

## Задача 16. Номер по сочетанию

Имя входного файла: choose2num.in

Имя выходного файла: choose2num.out

Во входном файле заданы числа _n_, _k_ и затем сочетание, состоящее из _k_ чисел от 1 до _n_. Выведите
в выходной файл номер этого сочетания в лексикографическом порядке всех сочетаний из _n_ чисел
по _k_ ( 1 ≤ _k_ ≤ _n_ ≤ 30 ). Сочетания нумеруются, начиная с 0.

### Пример

**choose2num.in**
```
4 2
2 3
```

**choose2num.out**
```
3
``` 

### [Решение](Combinatorics16.java)

## Задача 17. Правильная скобочная последовательность по номеру

Имя входного файла: num2brackets.in

Имя выходного файла: num2brackets.out

Во входном файле заданы числа _n_ и _k_. Выведите в выходной файл _k_-ю в лексикографическом
порядке правильную скобочную последовательность среди всех правильных скобочных последовательностей с _n_ открывающимися скобками, упорядоченных в лексикографическом порядке, "("<
")". Последовательности занумерованы, начиная с 0. 1 ≤ _n_ ≤ 20. Искомая последовательность
существует.

### Пример

**num2brackets.in**
```
4 3 
```

**num2brackets.out**
```
((()))()
```

### [Решение](Combinatorics17.java)

## Задача 18. Номер по правильной скобочной последовательности

Имя входного файла: brackets2num.in

Имя выходного файла: brackets2num.out

Во входном файле задана правильная скобочная последовательность. Выведите в выходной ее но-
мер в лексикографическом порядке среди всех правильных скобочных последовательностей с таким
же количеством открывающихся скобок, "("<")". Последовательности занумерованы, начиная с 0. Количество открывающихся скобок в последовательности  от 1 до 20.

### Пример

**brackets2num.in**
```
((()))()
```

**brackets2num.out**
```
3
```

### [Решение](Combinatorics18.java)

## Задача 19. Правильная скобочная последовательность с двумя типами скобок по номеру

Имя входного файла: num2brackets2.in

Имя выходного файла: num2brackets2.out

Во входном файле заданы числа _n_ и _k_. Выведите в выходной файл _k_-ю в лексикографическом
порядке правильную скобочную последовательность среди всех правильных скобочных последовательностей с двумя типами скобок с _n_ открывающимися скобками, упорядоченных в лексикографическом порядке, "("<")"<"["<"]". Последовательности занумерованы, начиная с 0. 1 ≤ _n_ ≤ 20.
Искомая последовательность существует.

### Пример

**num2brackets2.in**
```
4 100
```

**num2brackets2.out**
```
([])()[]
```

### [Решение](Combinatorics19.java)

## Задача 20. Номер по правильной скобочной последовательности с двумя типами скобок

Имя входного файла: brackets2num2.in

Имя выходного файла: brackets2num2.out

Во входном файле задана правильная скобочная последовательность с двумя типами скобок.
Выведите в выходной ее номер в лексикографическом порядке среди всех правильных скобочных
последовательностей с таким же количеством открывающихся скобок, "("< ")"< "[" < "]".
Последовательности занумерованы, начиная с 0. Количество открывающихся скобок в последовательности - от 1 до 20.

### Пример

**brackets2num2.in**
```
([])()[]
```

**brackets2num2.out**
```
100
```

### [Решение](Combinatorics20.java)

## Задача 21. Разбиение на слагаемые по номеру

Имя входного файла: num2part.in

Имя выходного файла: num2part.out

Рассмотрим все разбиения числа _n_ на слагаемые, в каждом разбиении упорядочим их в порядке
не убывания. Будем считать, что разбиение a_1 + a_2 +...+ a_n лексикографически меньше b_1 + b_2 +...+ b_m,
если для некоторого _k_ ∀_j_ ≤ _k_: a_j= b_j и либо _k_ = _n_, либо a_k+1 < b_k+1. Во входном файле заданы
числа _n_ и _r_. 1 ≤ _n_ ≤ 100 , разбиение с номеромr существует. Выведите _r_-ое разбиение числа _n_ на
слагаемые, разбиения нумеруются с 0.

### Пример

**num2part.in**
```
4 3
```

**num2part.out**
```
2+2
```

## Задача 22. Номер по разбиению на слагаемые

Имя входного файла: part2num.in

Имя выходного файла: part2num.out

Рассмотрим все разбиения числа _n_ на слагаемые, в каждом разбиении упорядочим их в порядке
не убывания. Будем считать, что разбиение a_1 + a_2 +...+ a_n лексикографически меньше b_1 + b_2 +...+ b_m,
если для некоторого _k_ ∀_j_ ≤ _k_: a_j = b_j и либо _k_ = _n_, либо a_k+1< b_k+1. Во входном файле задано
разбиение на слагаемые. Выведите номер этого разбиения, среди всех разбиений упорядоченных
лексикографически. Разбиения нумеруются с 0. Гарантируется, что в разбиении слагаемые упорядочены в порядке не убывания, и 1 ≤ _n_ ≤ 100.

### Пример

**part2num.in**
```
2+2
```

**part2num.out**
```
3
```

### [Решение](Combinatorics22.java)

## Задача 23. Предыдущий и следующий двоичный вектор

Имя входного файла: nextvector.in

Имя выходного файла: nextvector.out

Во входном файле задан двоичный вектор. Выведите в выходной файл предыдущий и следующий
двоичный вектор в лексикографическом порядке. Если какого-либо из них не существует, выведите
вместо него "-". Длина вектора во входном файле - от 1 до 200000.

### Пример

**nextvector.in**
```
10001
```

**nextvector.out**
```
10000
10010
```

**nextvector.in**
```
0 
```

**nextvector.out**
```
"-"
1
```

### [Решение](Combinatorics23.java)

## Задача 24. Предыдущая и следующая перестановки

Имя входного файла: nextperm.in

Имя выходного файла: nextperm.out

Во входном файле задано число _n_ и затем перестановка чисел от 1 до _n_. Выведите в выходной файл предыдущую и следующую перестановку чисел от 1 до _n_. Если какой либо из них не
существует, выведите вместо нее _n_ нулей. 1 ≤ _n_ ≤ 100 000.

### Пример

**nextperm.in**
```
4
1 3 2 4
```

**nextperm.out**
```
1 2 4 3
1 3 4 2
```

**nextperm.in**
```
2
1 2
```

**nextperm.out**
```
0 0
2 1
```

### [Решение](Combinatorics24.java)

## Задача 25. Cледующее сочетание

Имя входного файла: nextchoose.in

Имя выходного файла: nextchoose.out

Во входном файле заданы числа _n_, _k_ и затем сочетание, состоящее из _k_ чисел от 1 до _n_.
( 1 ≤ _k_ ≤ _n_ ≤ 10000 )
Выведите в выходной файл следующее сочетание в лексикографическом порядке из _n_ чисел по
_k_.
Если его не существует, выведите -1.

### Пример

**nextchoose.in**
```
4 2
2 3
```

**nextchoose.out**
```
2 4
```

**nextchoose.in**
```
4 2
3 4
```

**nextchoose.out**
```
-1
```

### [Решение](Combinatorics25.java)

## Задача 26. Следующее разбиение на множества

Имя входного файла: nextsetpartition.in

Имя выходного файла: nextsetpartition.out

Рассмотрим множество первых _n_ натуральных чисел: N_*n* = { 1 , 2 ,... , _n_}.Разбиением на множества называется представление этого множества, как объединения одного или более, попарно
непересекающихся подмножеств множеств. Например для _n_ = 5 существуют следующие разбиения:

```
{ 1 , 2 , 3 , 4 , 5 } = { 1 , 2 , 3 }∪{ 4 , 5 }
{ 1 , 2 , 3 , 4 , 5 } = { 1 , 3 , 5 }∪{ 2 , 4 }
{ 1 , 2 , 3 , 4 , 5 } = { 1 , 2 , 3 , 4 , 5 }
{ 1 , 2 , 3 , 4 , 5 } = { 1 } ∪ { 2 } ∪ { 3 } ∪ { 4 } ∪ { 5 }
```

Всего существует 52 разбиения множества N_5. Заметьте, что мы не различаем разбиения на множества, которые отличаются только порядком подмножеств.
Упорядочим все разбиения на множества N_*n* лексикографически. Для этого во-первых в каждом
разбиении упорядочим множества лексикографически. Будем говорить, что подмножество A ⊂ N_*n*
лексикографически меньше подмножества B ⊂ N_*n*, если верно одно из следующих условий:

* существует _i_ такое, что _i_ ∈ A, _i_ ∉ B, для всех _j_ < _i_:_j_ ∈ A если и только если _j_ ∈ B, и
    существует _k_ > _i_ такое что _k_ ∈ B;
* A ⊂ B и _i_ < _j_ для всех _i_ ∈ A и _j_ ∈ B\A.

Разбиения упорядочены лексикографически следующим образом. Разбиение
N_*n* = A_1 ∪ A_2 ∪ ... ∪ A_k лексикографически меньше разбиения N_n = B_1 ∪ B_2 ∪ ... ∪ B_l если
существует такое _i_, что A_1 = B_1, A_2 = B_2 ,... , A_i−1 = B_i−1 и A_i < B_i.
Дано разбиение N_*n*„ ваша задача найти следующее разбиение на множества в лексикографическом порядке.

### Формат входного файла

Во входном файле содержится несколько тестов. Каждый тест в первой строчке содержитnиk
количество чисел в разбиваемом множестве, и количество подмножеств в разбиении. ( 1 ≤ _n_ ≤ 200 ).
Следующие _k_ строк содержат элементы разбиения. Элементы в каждом подмножестве упорядочены
по возрастанию.
Тесты разделены пустой строкой. Последняя строка содержит два нуля.
Сумма всех _n_ по всем тестам не превосходит 2000.

### Формат выходного файла

Для каждого теста выведите в выходной файл следующее разбиение. Если разбиение во входном
файле является последним в лексикографическом порядке, то выведите первое в лексикографическом порядке разбиение. Используйте такой же формат, как и во входном файле. Разделяйте ответы
для разных тестов пустой строкой.

### Примеры

**nextsetpartition.in**
```
5 2
1 2 3
4 5

5 2
1 3 5
2 4

5 1
1 2 3 4 5

5 5
1
2
3
4
5

0 0
```

**nextsetpartition.out**
```
5 2
1 2 3 4
5

5 4
1 4
2
3
5

5 2
1 2 3 5
4

5 4
1
2
3
4 5
```

## Задача 27. Следующая правильная скобочная последовательность

Имя входного файла: nextbrackets.in

Имя выходного файла: nextbrackets.out

Во входном файле задана правильная скобочная последовательность. Выведите в выходной следующую за ней в лексикографическом порядке среди всех правильных скобочных последовательностей с таким же количеством открывающихся скобок, "("<")". Если такой нет, выведите "-".
Количество открывающихся скобок в последовательности - от 1 до100 000.

### Пример

**nextbrackets.in**
```
(())()()
```

**nextbrackets.out**
```
()((()))
```

### [Решение](Combinatorics27.java)

## Задача 28. Следующая мультиперестановка

Имя входного файла: nextmultiperm.in

Имя выходного файла: nextmultiperm.out

Во входном файле задано число _n_ и затем мультиперестановка, составленная из чисел от 1 до
_n_. Выведите в выходной файл следующую в лексикографическом порядке мультиперестановку того
же мультимножества. Если искомой перестановки не существует, выведите _n_ нулей. 1 ≤ _n_ ≤100 000.

### Пример

**nextmultiperm.in**
```
6
1 3 2 1 3 2
```

**nextmultiperm.out**
```
1 3 2 2 1 3
```

### [Решение](Combinatorics28.java)

## Задача 29. Следующее разбиение на слагаемые

Имя входного файла: nextpartition.in

Имя выходного файла: nextpartition.out

Разбиения числа _n_ на слагаемые - это набор целых положительных чисел, сумма которых равна _n_. При этом разбиения, отличающиеся лишь порядком слагаемых, считаются одинаковыми, поэтому можно считать, что слагаемые в разбиении упорядочены по неубыванию.
Например, существует 7 разбиений числа 5 на слагаемые:

```
5 = 1 + 1 + 1 + 1 + 1
5 = 1 + 1 + 1 + 2
5 = 1 + 1 + 3
5 = 1 + 2 + 2
5 = 1 + 4
5 = 2 + 3
5 = 5
```

В приведенном примере разбиения упорядочены _лексикографически_ - сначала по первому слагаемому в разбиении, затем по второму, и так далее. В этой задаче вам потребуется по заданному
разбиению на слагаемые найти следующее в лексикографическом порядке разбиение.

### Формат входного файла

Входной файл содержит одну строку - разбиение числа _n_ на слагаемые ( 1 ≤ _n_ ≤ 100 000).
Слагаемые в разбиении следуют в неубывающем порядке.

### Формат выходного файла

Выведите в выходной файл одну строку - разбиение числа _n_ на слагаемые, следующее в лексикографическом порядке после приведенного во входном файле. Если во входном файле приведено
последнее разбиение числа _n_ на слагаемые, выведите "No solution".

### Примеры

**nextpartition.in**
```
5=1+1+3
```

**nextpartition.out**
 ```
5=1+2+2
```

**nextpartition.in**
```
5=5
```

**nextpartition.out**
``` 
No solution
```

### [Решение](Combinatorics29.java)
