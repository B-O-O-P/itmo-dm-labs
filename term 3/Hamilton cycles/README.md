# Лабораторная работа по гамильтоновым циклам, 2016 год

## Задача A. Гамильтонов цикл в полном графе

Имя входного файла: fullham.in

Имя выходного файла: fullham.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дан граф из _N_ вершин, в котором степень любой вершины не меньше _N_/2. Ваша задача -
найти гамильтонов цикл.

### Формат входных данных

На первой строке входного файла записано целое число _N_ ( 3 ≤ _N_ ≤ 4 000) - количество
вершин в графе. На следующих _N_ строках записана матрица смежности. Т.к. матрица смежности симметрична, а на диагонали всегда стоят нули, на _i_-й строке записаны _i_− 1 символ
- нули и единицы. Если _j_-й символ _i_-й строки равен единице, значит есть ребро между
вершинами _i_ и _j_.
Гарантируется, что в графе есть гамильтонов цикл и, что степень каждой вершины не
меньше _N_/2.

### Формат выходных данных

Выведите перестановку из _N_ чисел - номера вершин в порядке гамильтонова цикла.

### Примеры

**fullham.in**
```
4

1
11
101
```

**fullham.out**
```
1 2 3 4
```

### [Решение](A.cpp)

## Задача B. Поиск гамильтонова цикла в условиях теоремы Хватала

Имя входного файла: chvatal.in

Имя выходного файла: chvatal.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дан граф из _N_ вершин, для которого выполняется условие теоремы Хватала, то есть, в
отсортированной последовательности его степеней вершин d_k для любого _k_ < _n_/2 верно либо
d_k > _k_, либо d_n−k ≥ n−k. Ваша задача - найти гамильтонов цикл.

### Формат входных данных

На первой строке входного файла записано целое число _N_ ( 3 ≤ _N_ ≤ 100 ) - количество
вершин в графе. На следующих _N_ строках записана матрица смежности. Т.к. матрица смежности симметрична, а на диагонали всегда стоят нули, на _i_-й строке записаны _i_− 1 символ
 нули и единицы. Если _j_-й символ _i_-й строки равен единице, значит есть ребро между
вершинами _i_ и _j_.

### Формат выходных данных

Выведите перестановку из _N_ чисел - номера вершин в порядке гамильтонова цикла.

### Примеры

**chvatal.in**
```
4

1
11
101
```

**chvatal.out**
```
1 2 3 4
```

### [Решение](B.cpp)

## Задача C. Интерактивная восточная сказка

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

У злого волшебника Джафара много ламп, которые он холит и лелеет, и любит очень
сильно, но из каждой пары ламп он всё же может выбрать одну, которую он любит даже
сильнее, чем другую.

Он захотел расставить их в ряд так, чтобы когда он будет идти вдоль этого ряда каждая
следующая лампа была им более любима, чем предыдущая.

Новому слуге Джафара поручено это сделать, но... он не знает предпочтений Джафара!
Про любую пару ламп можно спросить у волшебника, какую он любит больше, но нельзя
излишне навязываться с вопросами (отрубание головы еще никто не отменял).
Помогите слуге расположить лампы или узнать, что это невозможно (и сброситься со
скалы).

### Формат входных данных

Первое число, которое будет передано во входном потоке, - _N_ ( 1 ≤ _N_ ≤ 1000 ), количество
ламп.

Затем на каждый вопрос слуги, который ваша программа выведет в выходной поток, во
входном потоке будет дан ответ - слово “YES”, если лампа Y_i более любима чем X_i, и слово
“NO”, если X_i более любима чем Y_i.

Заметьте, что отношение "более любима чем" не обязано быть транзитивным.

### Формат выходных данных

В выходной файл вы можете выводить запросы Каждый вопрос - одна строчка с тремя
числами 1, X_i, Y_i ( 1 ≤ Xi, Y_i ≤ _N_; X_i ≠ Yi). Вы можете задать не более 10 000вопросов.

В последней строчке выведите число 0, а затем _N_ целых числел от 1 до _N_ - номера ламп
в порядке, в котором их надо расставить. Если же расставить лампы невозможно, выведите
(_N_ + 1)ноль.

### Примеры

**стандартный ввод**
```
3

YES

NO
```

**стандартный вывод**
```

1 1 2

1 1 3

0 3 1 2
```

### Замечание

Обязательно сбрасывайте буфер при выводе запросы: в Pascal используйте
`flush(output);`, в C используйте `fflush(stdout);`, в C++ используйте `cout.flush();`,
в Java используйте `System.out.flush();`.

### [Решение](C.cpp)

## Задача D. Цикл в турнире

Имя входного файла: guyaury.in

Имя выходного файла: guyaury.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Найдите гамильтонов цикл в полном ориентированном сильносвязном графе.

### Формат входных данных

В первой строке входного файла содержится число _n_( 1 ≤ _n_ ≤ 1000 ) - число вершин в
графе.

Далее следует _n_ строк имеющих длину, соответственно, 0, 1, 2,... , _n_ − 1. В _i_-й из этих
строк _j_-й символ задает равняется 1, если ребро ведет из вершины _i_ в вершину _j_, и 0, если
из вершины _j_ в вершину _i_.

### Формат выходных данных

В выходной файл выведите номера вершин в порядке их следования в найденном гамильтоновом цикле.

### Примеры

**guyaury.in**
```
3

1
01
```

**guyaury.out**
```
1 3 2
```

### [Решение](D.cpp)