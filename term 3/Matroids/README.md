
# Лабораторная работа «Матроиды».

## Задача A. Планирование заданий

Имя входного файла: schedule.in

Имя выходного файла: schedule.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Имеется некоторое множество заданий и один исполнитель. На выполнение одного задания уходит единица времени. Задания можно выполнять начинаяс момента времени 0. У каждого задания
есть две характеристики: d_i и w_i. Если задание не было выполнено к моменту времени d_i, взимается
штраф в размере w_i. Требуется минимизировать суммарный штраф.

### Формат входного файла

Первая строка входного файла содержит натуральное число _n_ — количество заданий
( 1 ≤ _n_ ≤ 100 000). Следующие _n_ строк содержат по два натуральных числа, разделенных пробелом
— d_i и w_i ( 0 ≤ d_i; w_i ≤ 10^9).

### Формат выходного файла

Выведите одно число — минимальный суммарный штраф.

### Примеры

**schedule.in**
```
2
1 1
1 2
```

**schedule.out**
```
1
```

### [Решение](../Planar%20graphs/A.cpp)

## Задача B. Уничтожение графа

Имя входного файла: destroy.in

Имя выходного файла: destroy.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 64мегабайта

Дан связный взвешенный граф. Требуется уничтожить максимальное количество ребер, чтобы
были выполнены следующие условия: суммарная стоимость уничтоженных ребер не превосходила
_s_, оставшийся после уничтожения граф должен быть связен.

### Формат входного файла

Первая строка входного файла содержит числа _n_ и _m_ — количество вершин и ребер в графе, и
_s_ — максимальную суммарную стоимость уничтоженных ребер ( 2 ≤ _n_ ≤ 50 000, 1 ≤ _m_ ≤ 100 000,
0 ≤ _s_ ≤ 10^18 ). Следующие _m_ строк описывают ребра — для каждого ребра указаны номера вершин,
которые оно соединяет, истоимость уничтожения этого ребра (непревышает 10^18).

### Формат выходного файла

На первой строке выходного файла выведите максимальное количество ребер, которые можно
уничтожить. На второй строке выведите их номера в порядке возрастания (ребра нумеруются с
единицы в порядке, в котором они заданы во входном файле).

### Пример

**destroy.in**
```
6 7 10
1 2 3
1 3 3
2 3 3
3 4 1
4 5 5
5 6 4
4 6 5
```

**destroy.out**
```
2
1 5
```

### [Решение](../Planar%20graphs/B.cpp)

## Задача C. Паросочетание максимального веса

Имя входного файла: matching.in

Имя выходного файла: matching.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дан двудольный граф. Количество вершин в левой и правой доле совпадает и равно _n_. У каждой
вершины левой доли есть вес, _i_-й вершине соответствует вес w_i. Вес паросочетания, ребрам которого инцидентны вершины левой доли a_1, a_2,..., a_k есть
√∑i=1..k: w^2,a_i. Требуется найти паросочетание
максимального веса.

### Формат входного файла

Первая строка входного файла содержит натуральное число _n_ — количество вершин в обеих
долях ( 1 ≤ _n_ ≤ 1000 ). Вторая строка входного файла содержит _n_ целых чисел w_1, w_2,...; w_n
( 1 ≤ w_i ≤ 1000 ). Следующие _n_ строк содержат описания ребер, инцидентных соответствующей
вершине левой доли. Формат описания: количество ребер, затем номера вершин правой доли, разделенные пробелом. Суммарное количество ребер не превосходит 200000.

### Формат выходного файла

Выведите _n_ чисел — для каждой вершины левой доли выведите номер вершины правой доли, с
которой ее надо взять в паросочетание. Если вершина не входит в паросочетание, выведите 0.

### Примеры

**matching.in**
```
4
1 3 2 4
4 1 2 3 4
2 1 4
2 1 4
2 1 4
```
**matching.out**
```
2 1 0 4
```

### [Решение](C.cpp)

## Задача D. Проверка

Имявходного файла: check.in

Имявыходного файла: check.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дано некоторое семейтво множеств _S_ ⊂ 2^*X*. Требуется проверить, может ли _S_ быть семейством
независимых множеств некоторого матроида.

### Формат входного файла

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — мощность множеств
_X_ и _S_ соответственно ( 1 ≤ _n_ ≤ 10 , 0 ≤ _m_ ≤ 2*n*). Каждая из следующих _m_ строк содержит описание
элемента множества _S_. Формат описания: количество элементов в подмножестве, затем через пробел
номера этих элементов. Элементы множества _X_ занумерованы начиная с единицы.

### Формат выходного файла

Выведите «YES», если _S_ может быть семейством независимых множеств некоторого матроида и
«NO» иначе.

### Примеры

**check.in**
```
2 4
0
1 1
1 2
2 1 2
```

**check.out**
```
YES
```

**check.in**
```
2 3
0
1 1
2 1 2
```

**check.out**
```
NO
```

### [Решение](../Planar%20graphs/D.cpp)

## Задача E. Циклы

Имя входного файла: cycles.in
Имя выходного файла: cycles.out
Ограничение по времени: 2 секунды
Ограничение по памяти: 256 мегабайт
Дано некоторое семейство множеств S ⊂ 2^*X*. Известно, что этом ножество циклов некоторого
матроида. Кроме того, у каждого элемента множества _X_ есть свой вес. Вес подможества _X_ есть
сумма весов элементов, принадлежащих ему. Требуется найти базу максимального веса.

### Формат входного файла

Первая строка входного файла содержит два натуральных числа _n_ и _m_ — мощность множеств
_X_ и _S_ соответственно (1 ≤ _n_ ≤ 20). Вторая строка входного файла содержит _n_ чисел w_1, w_2,..., w_n
(1 ≤ w_i ≤ 1000). Здесь элементы множества _X_ занумерованы начиная с единицы и w_i — вес _i_-го
элемета множества _X_. Каждая из следующих _m_ строк содержит описание элемента множества _S_.
Формат описания: количество элементов в подмножестве, затем через пробел номера этих элементов.

### Формат выходного файла

Выведите одно число — вес максимальной базы.

### Примеры

**cycles.in**
```
3 1
10 20 30
3 1 3 2
```

**cycles.out**
```
50
```

### [Решение](E.cpp)

